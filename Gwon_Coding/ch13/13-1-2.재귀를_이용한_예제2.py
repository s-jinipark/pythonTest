
def hanoi(n, A, B, C):
    if n == 1:
        print(f"{A} 기둥 에서 {C} 기둥으로 원반 1을 이동")
    else:
        hanoi(n-1, A, C, B) 
        print(f"{A} 기둥 에서 {C} 기둥으로 원반 {n}을 이동")
        hanoi(n-1, B, A, C)

hanoi(3, 1,2,3)


'''
[ chatGPT ]

이 문제는 기둥 A에 쌓인 원반들을 기둥 C로 옮기는 문제로, 다음의 규칙을 따릅니다.

1. 한 번에 하나의 원반만 이동할 수 있습니다.
2. 큰 원반 위에 작은 원반을 올릴 수 없습니다.
3. 모든 원반은 목적지인 기둥 C로 옮겨져야 합니다.

이 문제를 해결하기 위한 알고리즘은 다음과 같습니다.

1. n개의 원반을 A에서 C로 옮기기 위해, n-1개의 원반을 A에서 B로 옮깁니다.
2. 가장 큰 원반을 A에서 C로 옮깁니다.
3. B에 있는 n-1개의 원반을 C로 옮깁니다.

이 알고리즘은 재귀적으로 호출되며, 각 호출에서 n이 1이 될 때까지 작은 문제로 분할됩니다. 
따라서 이 알고리즘은 다음과 같은 재귀 함수로 구현할 수 있습니다.

'''
# 다른 풀이 (https://soohyun6879.tistory.com/190)
print('##### 연습_tmp ')
num = 4

def hanoi2(n, p_from, p_to, p_mid) :
    if n == 1 :  # 원반이 1개이면 무조건 원반을 1번에서 3번으로 옮긴다
        print(p_from, p_to)
        return

    hanoi2(n-1, p_from, p_mid, p_to) # 1번 기둥의 n-1 개의 원반을 2번 기둥으로 옮긴다
    print(p_from, p_to) # 1번 기둥에 남아 있는 가장 큰 원반을 3번 기둥으로 옮긴다
    hanoi2(n-1, p_mid, p_to, p_from) # 2번 기둥의 n-1 개의 원반을 3번 기둥으로 옮긴다

print(2**num-1)
hanoi2(num, 1,3,2)
